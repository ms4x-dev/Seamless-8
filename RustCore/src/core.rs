use prost::Message;
use serde_json::{Map, Value};
use hex;

// Generated by prost-build from proto/record.proto. The file name here must
// match what your build.rs produces (we standardized on demo.rs).
pub mod pb {
    include!(concat!(env!("OUT_DIR"), "/demo.rs"));
}

#[repr(u32)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Format {
    Json = 0,
    Protobuf = 1,
    Binary = 2, // alias for Protobuf bytes
    Hex = 3,    // hex-encoded Protobuf bytes
}

// Strict, schema-locked converter:
// 1) Always decode inputs into a canonical pb::Record.
// 2) Always encode outputs from that pb::Record.
//    - JSON  = canonical JSON {fields: map<string,string>, values: [u64]}
//    - Binary/Protobuf = prost-encoded bytes
//    - Hex = hex of prost bytes
pub fn convert_bytes(in_fmt: Format, out_fmt: Format, input: &[u8]) -> Result<Vec<u8>, String> {
    // --- Decode to canonical ---
    let rec = decode_to_record(in_fmt, input)?;
    // --- Encode from canonical ---
    encode_from_record(out_fmt, &rec)
}

fn decode_to_record(in_fmt: Format, input: &[u8]) -> Result<pb::Record, String> {
    match in_fmt {
        Format::Json => json_to_record(input),
        Format::Protobuf | Format::Binary => protobuf_to_record(input),
        Format::Hex => {
            let bytes = hex::decode(std::str::from_utf8(input).map_err(|e| e.to_string())?.trim())
                .map_err(|e| e.to_string())?;
            protobuf_to_record(&bytes)
        }
    }
}

fn encode_from_record(out_fmt: Format, rec: &pb::Record) -> Result<Vec<u8>, String> {
    match out_fmt {
        Format::Json => record_to_json(rec),
        Format::Protobuf | Format::Binary => record_to_protobuf(rec),
        Format::Hex => {
            let bytes = record_to_protobuf(rec)?;
            Ok(hex::encode(bytes).into_bytes())
        }
    }
}

// ---------- JSON <-> Record (STRICT) ----------
// We enforce a strict schema for JSON by mapping only known fields and
// rejecting unknown keys. This mirrors the Protobuf schema.
#[derive(serde::Deserialize)]
#[serde(deny_unknown_fields)]
struct JsonRecord {
    #[serde(default)]
    fields: std::collections::HashMap<String, String>,
    #[serde(default)]
    values: Vec<u64>,
}

fn json_to_record(input: &[u8]) -> Result<pb::Record, String> {
    let s = std::str::from_utf8(input).map_err(|e| e.to_string())?;
    let jr: JsonRecord = serde_json::from_str(s).map_err(|e| e.to_string())?;
    Ok(pb::Record { fields: jr.fields, values: jr.values })
}

fn record_to_json(rec: &pb::Record) -> Result<Vec<u8>, String> {
    let mut m = Map::new();
    m.insert("fields".into(), serde_json::to_value(&rec.fields).unwrap());
    m.insert("values".into(), serde_json::to_value(&rec.values).unwrap());
    Ok(serde_json::to_vec(&Value::Object(m)).unwrap())
}

// ---------- Protobuf <-> Record ----------
fn protobuf_to_record(input: &[u8]) -> Result<pb::Record, String> {
    pb::Record::decode(input).map_err(|e| e.to_string())
}

fn record_to_protobuf(rec: &pb::Record) -> Result<Vec<u8>, String> {
    let mut buf = Vec::with_capacity(128);
    rec.encode(&mut buf).map_err(|e| e.to_string())?;
    Ok(buf)
}
